#include <TeensyThreads.h>
#include <Audio.h>
#include <Wire.h>
#include <SPI.h>
#include <SD.h>
#include <SerialFlash.h>
#include <ArduinoQueue.h>

const int NUM_VOICES = 6;
// GUItool: begin automatically generated code
AudioSynthWaveform       lfo;      //xy=55,480.6262035369873
AudioSynthWaveform       vcfLFO;      //xy=55,480.6262035369873
AudioSynthWaveformDc     pwmDC;            //xy=55,600.2222118377686
AudioMixer4              pwmMix;         //xy=124.88888549804688,758.2222137451172
AudioEffectEnvelope      lfoEnv;      //xy=172.0001106262207,537.4447746276855
AudioEffectEnvelope      vcfLFOEnv;      //xy=172.0001106262207,537.4447746276855
AudioSynthWaveformDc     vcfEnvDC;            //xy=204.00000762939453,676.8283233642578
AudioSynthWaveformModulated pulse[NUM_VOICES]; //xy=299.8888854980469,1225.5555419921875
AudioSynthWaveformModulated saw[NUM_VOICES]; //xy=300.8888854980469,1255.5556030273438
AudioSynthWaveformModulated sub[NUM_VOICES]; //xy=298.88885498046875,1288.555477142334
AudioSynthNoiseWhite     noise[NUM_VOICES]; //xy=299.7979393005371,1319.9191417694092
AudioSynthWaveformDc     vcfEnvDCInv; //xy=316.0000305175781,718.2222442626953
AudioEffectEnvelope      vcfEnv;      //xy=318.8082046508789,627.666669845581
AudioMixer4              oscMixer[NUM_VOICES]; //xy=444.9797668457031,1274.9191074371338
AudioEffectMultiply      vcfMul;      //xy=454.00012969970703,673.2223968505859
AudioMixer4              vcfEnvMix; //xy=581.8889007568359,714.1110992431641
AudioFilterStateVariable hpf[NUM_VOICES]; //xy=607.6060371398926,1276.464765548706
AudioMixer4              vcfModMixer;         //xy=722.7373504638672,617.5758819580078
AudioFilterStateVariable vcf[NUM_VOICES]; //xy=805.9798278808594,1263.8283672332764
AudioEffectEnvelope      envelope[NUM_VOICES]; //xy=963.9799346923828,1269.5556030273438
AudioMixer4              voiceMix;         //xy=1227.555721282959,1063.3333320617676
AudioMixer4              voiceMix1; //xy=1235.888916015625,1297.6666259765625
AudioMixer4              finalMixer; //xy=1344.888916015625,1155.6666259765625
AudioOutputI2S           i2s1;           //xy=1497.0003066062927,1152.0913276672363       

AudioConnection          patchCord1(lfo, lfoEnv);

AudioConnection          patchCord2(pwmDC, 0, pwmMix, 1);
AudioConnection          patchCord3(pwmMix, 0, pulse[0], 1);
AudioConnection          patchCord4(vcfLFO, vcfLFOEnv);
//AudioConnection          patchCord4(lfoEnv, 0, vcfModMixer, 0);
AudioConnection          patchCord5(lfoEnv, 0, pulse[0], 0);
AudioConnection          patchCord6(lfoEnv, 0, saw[0], 0);
AudioConnection          patchCord7(lfoEnv, 0, sub[0], 0);
AudioConnection          patchCord8(lfoEnv, 0, pwmMix, 0);
AudioConnection          patchCord9(vcfEnvDC, vcfEnv);
AudioConnection          patchCord10(vcfEnvDC, 0, vcfEnvMix, 1);
AudioConnection          patchCord11(sub[3], 0, oscMixer[3], 2);
AudioConnection          patchCord12(sub[5], 0, oscMixer[5], 2);
AudioConnection          patchCord13(sub[2], 0, oscMixer[2], 2);
AudioConnection          patchCord14(pulse[3], 0, oscMixer[3], 0);
AudioConnection          patchCord15(sub[1], 0, oscMixer[1], 2);
AudioConnection          patchCord16(pulse[5], 0, oscMixer[5], 0);
AudioConnection          patchCord17(noise[3], 0, oscMixer[3], 3);
AudioConnection          patchCord18(pulse[2], 0, oscMixer[2], 0);
AudioConnection          patchCord19(noise[5], 0, oscMixer[5], 3);
AudioConnection          patchCord20(noise[2], 0, oscMixer[2], 3);
AudioConnection          patchCord21(sub[4], 0, oscMixer[4], 2);
AudioConnection          patchCord22(pulse[1], 0, oscMixer[1], 0);
AudioConnection          patchCord23(saw[3], 0, oscMixer[3], 1);
AudioConnection          patchCord24(noise[1], 0, oscMixer[1], 3);
AudioConnection          patchCord25(saw[5], 0, oscMixer[5], 1);
AudioConnection          patchCord26(sub[0], 0, oscMixer[0], 2);
AudioConnection          patchCord27(saw[2], 0, oscMixer[2], 1);
AudioConnection          patchCord28(pulse[4], 0, oscMixer[4], 0);
AudioConnection          patchCord29(noise[4], 0, oscMixer[4], 3);
AudioConnection          patchCord30(saw[1], 0, oscMixer[1], 1);
AudioConnection          patchCord31(pulse[0], 0, oscMixer[0], 0);
AudioConnection          patchCord32(noise[0], 0, oscMixer[0], 3);
AudioConnection          patchCord33(saw[4], 0, oscMixer[4], 1);
AudioConnection          patchCord34(saw[0], 0, oscMixer[0], 1);
AudioConnection          patchCord35(vcfEnvDCInv, 0, vcfMul, 1);
AudioConnection          patchCord36(vcfEnv, 0, vcfMul, 0);
AudioConnection          patchCord37(vcfEnv, 0, pwmMix, 2);
AudioConnection          patchCord38(oscMixer[3], 0, hpf[3], 0);
AudioConnection          patchCord39(oscMixer[5], 0, hpf[5], 0);
AudioConnection          patchCord40(oscMixer[2], 0, hpf[2], 0);
AudioConnection          patchCord41(oscMixer[1], 0, hpf[1], 0);
AudioConnection          patchCord42(oscMixer[4], 0, hpf[4], 0);
AudioConnection          patchCord43(oscMixer[0], 0, hpf[0], 0);
AudioConnection          patchCord44(vcfMul, 0, vcfEnvMix, 0);
AudioConnection          patchCord45(vcfEnvMix, 0, vcfModMixer, 1);
AudioConnection          patchCord46(hpf[3], 2, vcf[3], 0);
AudioConnection          patchCord47(hpf[5], 2, vcf[5], 0);
AudioConnection          patchCord48(hpf[2], 2, vcf[2], 0);
AudioConnection          patchCord49(hpf[1], 2, vcf[1], 0);
AudioConnection          patchCord50(hpf[4], 2, vcf[4], 0);
AudioConnection          patchCord51(hpf[0], 2, vcf[0], 0);
AudioConnection          patchCord52(vcfModMixer, 0, vcf[0], 1);
AudioConnection          patchCord53(vcf[3], 0, envelope[3], 0);
AudioConnection          patchCord54(vcf[5], 0, envelope[5], 0);
AudioConnection          patchCord55(vcf[2], 0, envelope[2], 0);
AudioConnection          patchCord56(vcf[1], 0, envelope[1], 0);
AudioConnection          patchCord57(vcf[4], 0, envelope[4], 0);
AudioConnection          patchCord58(vcf[0], 0, envelope[0], 0);
AudioConnection          patchCord59(envelope[3], 0, voiceMix1, 0);
AudioConnection          patchCord60(envelope[5], 0, voiceMix1, 2);
AudioConnection          patchCord61(envelope[2], 0, voiceMix, 2);
AudioConnection          patchCord62(envelope[1], 0, voiceMix, 1);
AudioConnection          patchCord63(envelope[4], 0, voiceMix1, 1);
AudioConnection          patchCord64(envelope[0], 0, voiceMix, 0);
AudioConnection          patchCord65(voiceMix, 0, finalMixer, 0);
AudioConnection          patchCord66(voiceMix1, 0, finalMixer, 1);
AudioConnection          patchCord67(finalMixer, 0, i2s1, 0);
AudioConnection          patchCord68(finalMixer, 0, i2s1, 1);
AudioConnection          patchCord69(vcfLFOEnv, 0, vcfModMixer, 0);
AudioConnection          patchCord70(vcfModMixer, 0, vcf[1], 1);
// AudioConnection          patchCord52(vcfModMixer, 0, vcf[0], 1);
AudioControlSGTL5000     sgtl5000_1;     //xy=1005,457
// GUItool: end automatically generated code

const int numAnalogPins = 4;
const int numDigitalPins = 7;
const int analogPins[] = {A0, A1, A2, A3}; // DEMO CODE ANALOG PINS
const int digitalPins[] = {0, 1, 2, 3, 4, 5, 9}; // demo code digital pins
int dVals[numDigitalPins];
int aVals[numAnalogPins];
float attack = 50;
float decay = 500;
float sustain = 1;
float release = 100;
bool pulseTog = true, sawTog = true, subTog = true, gateTog = true, envPol = true, lfoTog = true;
float gainVal, chGain, subGain, noiseGain = 0.0;
int wavesOn;
float vcfFreq = 14000.0, vcfRes = 0.7, vcflfoAmp = 0.0, vcfEnvAmp = 0.0, vcfOctCon = 0.0;
//unsigned long startTime, endTime;
const float VCF_MAX = 14450.0;
float noiseAmp = 0.25;
float subAmp;
float lfoAmp, pwmAmp;

float lfoGain, vcfEnvGain, vcfLFOGain;

float lfoFreq, lfoDelay, hpfFreq = 10.0, vcaAmp; 
//voice handling

int voicesMIDI[NUM_VOICES]; // holds the MIDI notes of all voices
int voicesOn = 0; // stores number of voices currently on
//ArduinoQueue<ReleasedVoice> voicesReleased(NUM_VOICES); // holds the id for the thread created when a voice is released
//bool voicesOn[NUM_VOICES];
int voiceIndex;

int control = 0;

float freq;
//char control [4];
void setup() {
  AudioMemory(120);

  Serial.begin(115200);
  pinMode(13, OUTPUT);

  sgtl5000_1.enable();
  sgtl5000_1.volume(0.8);

  // Initialize digital pins as inputs
  for (int i = 0; i < sizeof(digitalPins) / sizeof(digitalPins[0]); i++) {
    pinMode(digitalPins[i], INPUT);
  }

  // init analog pins for input
  for (int i = 0; i < numAnalogPins; i++)
  {
    pinMode(analogPins[i], INPUT);
  }
  // set all voices off
  for(int i = 0; i < NUM_VOICES; i++) {
    //voicesOn[i] = 0;
    voicesMIDI[i] = -1;
    pulse[i].begin(WAVEFORM_PULSE);
    saw[i].begin(WAVEFORM_SAWTOOTH);
    sub[i].begin(WAVEFORM_SQUARE);

    
    pulse[i].amplitude(1);
    saw[i].amplitude(1);
    sub[i].amplitude(1);
    noise[i].amplitude(1);
    
    oscMixer[i].gain(0,0.33);
    oscMixer[i].gain(1,0.33);
    oscMixer[i].gain(2,0.33);
    oscMixer[i].gain(3,0.33);

    envelope[i].attack(attack);
    envelope[i].decay(decay);
    envelope[i].sustain(sustain);
    envelope[i].release(release);

    vcf[i].frequency(vcfFreq);
    vcf[i].resonance(vcfRes);
    vcf[i].octaveControl(vcfOctCon);

    hpf[i].frequency(hpfFreq);


  }
  lfo.begin(WAVEFORM_TRIANGLE);
  lfo.frequency(0.3);
  lfo.amplitude(0.0);

  vcfLFO.begin(WAVEFORM_TRIANGLE);
  vcfLFO.frequency(0.3);
  vcfLFO.amplitude(1.0);

  vcfEnv.attack(attack);
  vcfEnv.decay(decay);
  vcfEnv.sustain(sustain);
  vcfEnv.release(release);

  vcfLFOEnv.attack(attack);
  vcfLFOEnv.decay(decay);
  vcfLFOEnv.sustain(sustain);
  vcfLFOEnv.release(release);

  vcfEnvDC.amplitude(-1.0);
  vcfEnvDCInv.amplitude(-1.0);

  pwmMix.gain(0, 0.0);
  pwmMix.gain(1, 1.0);
  pwmMix.gain(2, 0.0);
  voiceMix.gain(0, 0.33);
  voiceMix.gain(1, 0.33);
  voiceMix.gain(2, 0.33);
  voiceMix1.gain(0, 0.33);
  voiceMix1.gain(1, 0.33);
  voiceMix1.gain(2, 0.33);

  


  threads.addThread(midi_reader);
//  threads.addThread(serial_read);
  threads.addThread(readAnalogPins);
  threads.addThread(readDigitalPins);
  // threads.addThread(toggleLED);
  while(1) {
    threads.idle();
  }
}

// void serial_read() {
//   // data will come in 2 bytes at a time. 
//   // the format for the data will be one 5 bit parameter id (I), and 10 bit value(V), with 1 extra bit (X) 
//   // INPUT: XIII IIVV  VVVV VVVV
  
//   while (1) {
//     if (Serial.available() > 0) {
//       Serial.readBytes(control, 4);
//       Serial.print("Received: ");
//       Serial.println(control);
//     }
//     threads.yield();
//   }
// }

void loop() {
  // usbMIDI.read() needs to be called rapidly from loop().  When
  // each MIDI messages arrives, it return true.  The message must
  // be fully processed before usbMIDI.read() is called again.
  // if (usbMIDI.read()) {
  //   processMIDI();
  // }
}

void processMIDI(void) {
  
  byte type, channel, data1, data2;

  // fetch the MIDI message, defined by these 5 numbers (except SysEX)
  //
  type = usbMIDI.getType();       // which MIDI message, 128-255
  channel = usbMIDI.getChannel(); // which MIDI channel, 1-16
  data1 = usbMIDI.getData1();     // first data byte of message, 0-127
  data2 = usbMIDI.getData2();     // second data byte of message, 0-127

  float noteFreq = midi_to_freq(data1);


  switch (type) {
    case usbMIDI.NoteOff: // 0x80
      Serial.print("Note Off, ch=");
      Serial.print(channel, DEC);
      Serial.print(", note=");
      Serial.print(data1, DEC);
      Serial.print(", velocity=");
      Serial.println(data2, DEC);
      digitalWrite(13, LOW);
      int i;
      for(i = 0; i < NUM_VOICES; i++) {
        if (voicesMIDI[i] == data1) {
          break;
        }
          
      }

      if (i != NUM_VOICES) { // found voice turned off
        voicesOn--;
        envelope[i].noteOff();
        voicesMIDI[i] = -1;
      }
      if(voicesOn == 0) {
          Serial.println("VCF LFO Env Note On");

        vcfLFOEnv.noteOff();
        vcfEnv.noteOff();
        lfoEnv.noteOff();
      }
      Serial.println(voicesOn);

      

      //ReleasedVoice v;
      //v.voiceIndex = i;
      //v.releaseThread = threads.addThread(releaseVoice, v.voiceIndex);
      //voicesReleased.enqueue(v);

      break;

    case usbMIDI.NoteOn: // 0x90
      Serial.print("Note On, ch=");
      Serial.print(channel, DEC);
      Serial.print(", note=");
      Serial.print(data1, DEC);
      Serial.print(", velocity=");
      Serial.println(data2, DEC);
      digitalWrite(13, HIGH);
      Serial.print("Frequency: ");
      Serial.println(midi_to_freq(data1));

      voiceIndex = findOpenVoice(voicesMIDI);


      if (voiceIndex != -1) { // found empty voice
        voicesMIDI[voiceIndex] = (int)data1;

        if (voicesOn == 0) {
          Serial.println("VCF LFO Env Note On");
          vcfLFOEnv.noteOn();
        }
        voicesOn++;
        Serial.println(voicesOn);
        pulse[voiceIndex].frequency(noteFreq); // incoming pulse[i]
        saw[voiceIndex].frequency(noteFreq);
        sub[voiceIndex].frequency(noteFreq/2.0);
        
        envelope[voiceIndex].noteOn();
        vcfEnv.noteOn();
        lfoEnv.noteOn();
      }
      else {
        break;
      }

      //kybd.frequency(noteFreq);
      break;

    case usbMIDI.AfterTouchPoly: // 0xA0
      Serial.print("AfterTouch Change, ch=");
      Serial.print(channel, DEC);
      Serial.print(", note=");
      Serial.print(data1, DEC);
      Serial.print(", velocity=");
      Serial.println(data2, DEC);
      break;

    case usbMIDI.ControlChange: // 0xB0
      Serial.print("Control Change, ch=");
      Serial.print(channel, DEC);
      Serial.print(", control=");
      Serial.print(data1, DEC);
      Serial.print(", value=");
      Serial.println(data2, DEC);
      break;

    case usbMIDI.ProgramChange: // 0xC0
      Serial.print("Program Change, ch=");
      Serial.print(channel, DEC);
      Serial.print(", program=");
      Serial.println(data1, DEC);
      break;

    case usbMIDI.AfterTouchChannel: // 0xD0
      Serial.print("After Touch, ch=");
      Serial.print(channel, DEC);
      Serial.print(", pressure=");
      Serial.println(data1, DEC);
      break;

    case usbMIDI.PitchBend: // 0xE0
      Serial.print("Pitch Change, ch=");
      Serial.print(channel, DEC);
      Serial.print(", pitch=");
      Serial.println(data1 + data2 * 128, DEC);
      break;

    case usbMIDI.SystemExclusive: // 0xF0
      // Messages larger than usbMIDI's internal buffer are truncated.
      // To receive large messages, you *must* use the 3-input function
      // handler.  See InputFunctionsComplete for details.
      Serial.print("SysEx Message: ");
      printBytes(usbMIDI.getSysExArray(), data1 + data2 * 256);
      Serial.println();
      break;

    case usbMIDI.TimeCodeQuarterFrame: // 0xF1
      Serial.print("TimeCode, index=");
      Serial.print(data1 >> 4, DEC);
      Serial.print(", digit=");
      Serial.println(data1 & 15, DEC);
      break;

    case usbMIDI.SongPosition: // 0xF2
      Serial.print("Song Position, beat=");
      Serial.println(data1 + data2 * 128);
      break;

    case usbMIDI.SongSelect: // 0xF3
      Serial.print("Sond Select, song=");
      Serial.println(data1, DEC);
      break;

    case usbMIDI.TuneRequest: // 0xF6
      Serial.println("Tune Request");
      break;

    case usbMIDI.Clock: // 0xF8
      Serial.println("Clock");
      break;

    case usbMIDI.Start: // 0xFA
      Serial.println("Start");
      break;

    case usbMIDI.Continue: // 0xFB
      Serial.println("Continue");
      break;

    case usbMIDI.Stop: // 0xFC
      Serial.println("Stop");
      break;

    case usbMIDI.ActiveSensing: // 0xFE
      Serial.println("Actvice Sensing");
      break;

    case usbMIDI.SystemReset: // 0xFF
      Serial.println("System Reset");
      break;

    default:
      Serial.println("Opps, an unknown MIDI message type!");
  }
}

int findOpenVoice(int * voices) {
  for(int i = 0; i < NUM_VOICES; i++) {
    Serial.print("Voices[");
    Serial.print(i);
    Serial.print("]: ");
    Serial.println(voices[i]);
    if (voices[i] == -1) {
      Serial.print("found empty voice at index ");
      Serial.println(i);
      return i;
    }
  }
  // if no empty voices, we'll return -1
  return -1;
}
void printBytes(const byte *data, unsigned int size) {
  while (size > 0) {
    byte b = *data++;
    if (b < 16) Serial.print('0');
    Serial.print(b, HEX);
    if (size > 1) Serial.print(' ');
    size = size - 1;
  }
}
float midi_to_freq(int note) {
  return 440.0f*pow(2,(note-69)/12.0f);
}

void midi_reader(){
  while (1) {
    
    if (usbMIDI.read()) {
      processMIDI();    }
    threads.yield();
  }
}
float mapToRange(int inputValue, float bottom,float top) {
  return (((float)inputValue / 1023.0) * (top - bottom)) + bottom;
}
float mapToRangeExp(int inputValue, float bottom, float top) {
  // input = 0-1023
  //output = a number between bottom to top, scaled expontentially
  return (pow(2.0,(inputValue/1023.0)) - 1) * (top - bottom) + bottom;
}
// float log2(float x) {
//   return (log(x)/log(2));
// }
float getOctControl() {
  float octCon = log2(VCF_MAX/vcfFreq);
  // Serial.print("Oct control: ");
  // Serial.println(octCon);
  return (octCon);
}
void readAnalogPins() {
  while(true) {

    for(int i = 0; i < numAnalogPins; i++) {
      aVals[i] = analogRead(analogPins[i]);
    }
    switch (control) {
      case 0:
        vcaAmp = mapToRange(aVals[3], 0.0, 0.5);
        pwmAmp   = mapToRange(aVals[2], 0.0, 0.95);
        subAmp   = mapToRange(aVals[1], 0.0, 1.0);
        noiseAmp = mapToRange(aVals[0], 0.0, 1.0);

        // finalMixer.gain(0,vcaAmp);
        // finalMixer.gain(1, vcaAmp);
        lfo.amplitude(lfoAmp*lfoTog);
        pwmDC.amplitude(pwmAmp);
        // loop not needed as readDigitalPins takes care of setting amplitude

      break;
      case 1:
        vcfFreq = mapToRangeExp(aVals[3], 750, 14000.0);
        vcfRes  = mapToRangeExp(aVals[2], 0.7, 5.0);
        vcflfoAmp = mapToRange(aVals[1], 0, 0.5); 
        vcfEnvAmp = mapToRange(aVals[0], 0, 0.5);

        Serial.println(vcflfoAmp);
        Serial.println(vcfEnvAmp);

        vcfModMixer.gain(0,vcflfoAmp);
        vcfModMixer.gain(1,vcfEnvAmp);

        vcfOctCon = getOctControl();

        for(int i = 0; i < NUM_VOICES; i++) {
          // do for all voices
          vcf[i].frequency(vcfFreq);
          vcf[i].resonance(vcfRes);
          vcf[i].octaveControl(vcfOctCon);
        }



      break;
      case 2:
        attack = mapToRangeExp(aVals[3], 1.0, 3000.0);
        decay  = mapToRangeExp(aVals[2], 2.0, 12000.0);
        sustain = mapToRange(aVals[1], 0, 1.0);
        release = mapToRangeExp(aVals[0], 2.0, 12000.0); 
        if(!gateTog) {
          for(int i = 0; i < NUM_VOICES; i++) {
              envelope[i].attack(attack);
              envelope[i].decay(decay);
              envelope[i].sustain(sustain);
              envelope[i].release(release);
          }
        }
        vcfEnv.attack(attack);
        vcfEnv.decay(decay);
        vcfEnv.sustain(sustain);
        vcfEnv.release(release);


      break;
      case 3:
        lfoAmp = mapToRangeExp(aVals[3], 0, .1); // lfoAmp
        lfoFreq  = mapToRangeExp(aVals[2], 0.3, 20.0);
        lfoDelay  = mapToRangeExp(aVals[1], 0.0, 1500.0);
        hpfFreq = mapToRange(aVals[0], 10.0, 5000.0);

        lfo.amplitude(lfoAmp*lfoTog);
        lfo.frequency(lfoFreq);

        vcfLFO.frequency(lfoFreq);

        lfoEnv.attack(lfoDelay);
        vcfLFOEnv.attack(lfoDelay);

        for(int i = 0; i < NUM_VOICES; i++) {
          // do for all voices
          hpf[i].frequency(hpfFreq);
        }

        
      break;

      default: 
        Serial.println("Out of valid control inputs");
    }

    threads.yield();
  }
}
void readDigitalPins() {
  while(true) {
    // unsigned long startTime = millis();
    for(int i = 0; i < numDigitalPins; i++) {
      dVals[i] = digitalRead(digitalPins[i]);
    }
    
    pulseTog = (dVals[0]) ? 1 : 0;
    sawTog = (dVals[1]) ? 1 : 0;
    subTog = (dVals[2]) ? 1 : 0;
    
    gateTog = (dVals[3]) ? 1 : 0;
    lfoTog = (dVals[6]) ? 1 : 0;

    control = (dVals[4] | (dVals[5] << 1));

    wavesOn = pulseTog + sawTog + subTog;
    switch (subTog) {
       case 0: // sub is used
         gainVal = wavesOn + noiseAmp;
         noiseGain = noiseAmp / gainVal;
         chGain = 1 / gainVal;
        break;
       case 1: 
         gainVal = wavesOn + noiseAmp + subAmp - 1;
         noiseGain = noiseAmp/gainVal;
         subGain = subAmp/gainVal;
         chGain = 1/gainVal;
         break;
      }
    
    if (gateTog) {
      for(int i = 0; i < NUM_VOICES; i++) {
          envelope[i].attack(0.0);
          envelope[i].decay(0.0);
          envelope[i].sustain(1);
          envelope[i].release(0.0);
      }
    }
    if (lfoTog) {
      lfo.amplitude(1.0*lfoAmp);
    }
    else {
      lfo.amplitude(0.0*lfoAmp);
    }
    for(int i = 0; i < NUM_VOICES; i++) {
      pulse[i].amplitude(pulseTog);
      saw[i].amplitude(sawTog);

      oscMixer[i].gain(0,chGain);
      oscMixer[i].gain(1,chGain);
      oscMixer[i].gain(2,subGain*subTog);
      oscMixer[i].gain(3,noiseGain);
    }
    
    /*
    1 -> 1a
    2 -> 0.5
    3 -> 0.33
    consider noise. noise = 0.5, others are 0.4, noise is 0.2, x + 2x + 2x
    noise = 1, x + x + x = 1;
    noise = 0.25, x + 4x + 4x = 1;aaaa
    noise = n, x + (1/n)x + (1/n)x = 1;
    input: wavesOn, subAmp, noiseAmp
    
    
    
    this is the amplification
    consider square
    square = full, noise = 0.5, x + 2x + 2x + 2x = 1
    square = 0.5, noise = 0.5, x + x + 2x + 2x
    square = 0.25, noise = 0.75, x + 3x + 4x + 4x = 1 => x = 0.825

    */

    //control = dVals[4] | dVals[5] << 1 | dVals[6] << 2; 
    // unsigned long endTime = millis();
    // Serial.print("Digital Pin Processing Time: ");
    // Serial.println(endTime-startTime);
    threads.yield();
  }
}


